<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Winter AR Scene â€¢ A-Frame</title>
    <meta name="description" content="Winter AR Scene - Tap to place snowmen and trees">
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <script>
      /**
       * AR HIT TEST SPAWN COMPONENT
       * Custom A-Frame component that handles AR surface detection and spawns winter objects.
       * Uses WebXR's native hit-test API to detect real-world surfaces and place virtual objects.
       * Alternates between spawning snowmen and pine trees with each tap.
       */
      AFRAME.registerComponent('ar-hit-test-spawn', {
        /**
         * Initialize the component when it's first attached to the scene
         * Sets up event listeners and state variables
         */
        init() {
          // Store reference to the main A-Frame scene
          this.scene = this.el.sceneEl;
          
          // Counter to track how many objects have been spawned
          this.objectCounter = 0;
          
          // Track which type of object to spawn next (alternates between 'snowman' and 'tree')
          this.objectType = 'snowman';
          
          // Bind the onSelect method to maintain correct 'this' context
          this.onSelect = this.onSelect.bind(this);
          
          /**
           * EVENT: enter-vr
           * Fired when the user enters AR/VR mode by clicking the AR button
           * This is where we set up WebXR hit testing
           */
          this.scene.addEventListener('enter-vr', () => {
            console.log('Entered VR/AR mode');
            
            // Check if we're in AR mode (not regular VR)
            if (this.scene.is('ar-mode')) {
              console.log('AR mode confirmed, setting up hit testing...');
              
              // Get the WebXR session from the Three.js renderer
              this.xrSession = this.scene.renderer.xr.getSession();
              
              if (this.xrSession) {
                console.log('XR session obtained');
                
                // Listen for 'select' events (triggered when user taps the screen)
                this.xrSession.addEventListener('select', this.onSelect);
                console.log('Select event listener added');
                
                /**
                 * Set up XR hit test source
                 * This allows us to detect where the user taps on real-world surfaces
                 * 
                 * Step 1: Request a 'viewer' reference space (camera's perspective)
                 * Step 2: Request a hit test source using that reference space
                 * The hit test source will continuously check for surface intersections
                 */
                this.xrSession.requestReferenceSpace('viewer').then((refSpace) => {
                  console.log('Viewer reference space obtained');
                  this.xrViewerSpace = refSpace;
                  
                  // Request hit test source - this enables surface detection
                  this.xrSession.requestHitTestSource({ space: this.xrViewerSpace }).then((hitTestSource) => {
                    this.xrHitTestSource = hitTestSource;
                    console.log('Hit test source created successfully');
                  }).catch((error) => {
                    console.error('Failed to create hit test source:', error);
                  });
                }).catch((error) => {
                  console.error('Failed to get reference space:', error);
                });
              } else {
                console.error('No XR session available');
              }
            }
          });
          
          /**
           * EVENT: exit-vr
           * Fired when the user exits AR mode
           * Clean up resources to prevent memory leaks
           */
          this.scene.addEventListener('exit-vr', () => {
            // Cancel the hit test source if it exists
            if (this.xrHitTestSource) {
              this.xrHitTestSource.cancel();
              this.xrHitTestSource = null;
            }
            
            // Remove the select event listener
            if (this.xrSession) {
              this.xrSession.removeEventListener('select', this.onSelect);
              this.xrSession = null;
            }
          });
        },
        
        /**
         * TICK METHOD
         * Called every frame (typically 60-90 times per second in AR)
         * Continuously checks for hit test results to find where the user is pointing
         */
        tick() {
          // Exit early if we don't have a hit test source or aren't in AR mode
          if (!this.xrHitTestSource || !this.scene.is('ar-mode')) return;
          
          // Get the current XR frame (contains pose and hit test data)
          const frame = this.scene.frame;
          if (!frame) return;
          
          // Query the hit test source for results (where the device is pointing at surfaces)
          const hitTestResults = frame.getHitTestResults(this.xrHitTestSource);
          
          // If we detected a surface
          if (hitTestResults.length > 0) {
            // Get the first (closest) hit result
            const hit = hitTestResults[0];
            
            // Get the pose (position and orientation) of the hit point in 3D space
            const pose = hit.getPose(this.scene.renderer.xr.getReferenceSpace());
            
            // Store the pose so we can use it when the user taps
            if (pose) {
              this.lastHitPose = pose;
            }
          }
        },
        
        /**
         * ON SELECT METHOD
         * Called when the user taps the screen in AR mode
         * Creates and spawns a new snowman or pine tree at the tapped location
         */
        onSelect() {
          console.log('Select event fired!');
          
          // Exit if we don't have a valid hit pose (no surface detected)
          if (!this.lastHitPose) {
            console.warn('No hit pose available - no surface detected');
            return;
          }
          
          console.log('Hit pose available, spawning object...');
          
          // Extract the 3D position from the hit pose
          const position = this.lastHitPose.transform.position;
          console.log('Position:', position.x, position.y, position.z);
          
          // Create a new container entity to hold the snowman or tree
          const container = document.createElement('a-entity');
          container.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
          container.setAttribute('scale', '0.15 0.15 0.15'); // Scale down to appropriate AR size
          
          // Alternate between spawning snowman and tree
          if (this.objectType === 'snowman') {
            // Create a snowman in the container
            this.createSnowman(container);
            console.log('Spawned snowman #' + (this.objectCounter + 1));
            
            // Next tap will spawn a tree
            this.objectType = 'tree';
          } else {
            // Create a pine tree in the container
            this.createTree(container);
            console.log('Spawned pine tree #' + (this.objectCounter + 1));
            
            // Next tap will spawn a snowman
            this.objectType = 'snowman';
          }
          
          // Add the container (with snowman or tree) to the scene
          this.scene.appendChild(container);
          console.log('Object added to scene');
          
          // Increment the counter
          this.objectCounter++;
        },
        
        /**
         * CREATE SNOWMAN METHOD
         * Procedurally generates a snowman using basic 3D shapes
         * @param {HTMLElement} container - The parent entity to attach snowman parts to
         */
        createSnowman(container) {
          // Bottom sphere (largest) - base of the snowman
          const bottom = document.createElement('a-sphere');
          bottom.setAttribute('radius', '0.6');
          bottom.setAttribute('position', '0 0.6 0');
          bottom.setAttribute('color', '#FFFFFF'); // White
          bottom.setAttribute('shadow', 'cast: true'); // Enable shadow casting
          container.appendChild(bottom);
          
          // Middle sphere (medium) - torso
          const middle = document.createElement('a-sphere');
          middle.setAttribute('radius', '0.45');
          middle.setAttribute('position', '0 1.4 0');
          middle.setAttribute('color', '#FFFFFF');
          middle.setAttribute('shadow', 'cast: true');
          container.appendChild(middle);
          
          // Head sphere (smallest) - the head
          const head = document.createElement('a-sphere');
          head.setAttribute('radius', '0.3');
          head.setAttribute('position', '0 2 0');
          head.setAttribute('color', '#FFFFFF');
          head.setAttribute('shadow', 'cast: true');
          container.appendChild(head);
          
          // Left eye - small black sphere
          const leftEye = document.createElement('a-sphere');
          leftEye.setAttribute('radius', '0.05');
          leftEye.setAttribute('position', '-0.1 2.05 0.25'); // Positioned on left side of face
          leftEye.setAttribute('color', '#000000'); // Black
          container.appendChild(leftEye);
          
          // Right eye - small black sphere
          const rightEye = document.createElement('a-sphere');
          rightEye.setAttribute('radius', '0.05');
          rightEye.setAttribute('position', '0.1 2.05 0.25'); // Positioned on right side of face
          rightEye.setAttribute('color', '#000000');
          container.appendChild(rightEye);
          
          // Carrot nose - orange cone rotated to point forward
          const nose = document.createElement('a-cone');
          nose.setAttribute('radius-bottom', '0.05');
          nose.setAttribute('radius-top', '0');
          nose.setAttribute('height', '0.2');
          nose.setAttribute('position', '0 1.95 0.35'); // In front of the face
          nose.setAttribute('rotation', '90 0 0'); // Rotate 90 degrees to point outward
          nose.setAttribute('color', '#FF6347'); // Tomato orange/red
          container.appendChild(nose);
          
          // Button 1 (top button) - coal button on torso
          const button1 = document.createElement('a-sphere');
          button1.setAttribute('radius', '0.06');
          button1.setAttribute('position', '0 1.5 0.42'); // On front of torso
          button1.setAttribute('color', '#000000');
          container.appendChild(button1);
          
          // Button 2 (bottom button) - coal button on torso
          const button2 = document.createElement('a-sphere');
          button2.setAttribute('radius', '0.06');
          button2.setAttribute('position', '0 1.3 0.43');
          button2.setAttribute('color', '#000000');
          container.appendChild(button2);
          
          // Hat brim - flat black cylinder (wider)
          const hatBrim = document.createElement('a-cylinder');
          hatBrim.setAttribute('radius', '0.35');
          hatBrim.setAttribute('height', '0.1');
          hatBrim.setAttribute('position', '0 2.4 0'); // On top of head
          hatBrim.setAttribute('color', '#000000');
          container.appendChild(hatBrim);
          
          // Hat top - tall black cylinder (narrower) - classic top hat
          const hatTop = document.createElement('a-cylinder');
          hatTop.setAttribute('radius', '0.2');
          hatTop.setAttribute('height', '0.5');
          hatTop.setAttribute('position', '0 2.7 0'); // Stacked on top of brim
          hatTop.setAttribute('color', '#000000');
          container.appendChild(hatTop);
        },
        
        /**
         * CREATE TREE METHOD
         * Procedurally generates a pine tree with trunk, foliage tiers, and star
         * @param {HTMLElement} container - The parent entity to attach tree parts to
         */
        createTree(container) {
          // Trunk - brown cylinder at the base
          const trunk = document.createElement('a-cylinder');
          trunk.setAttribute('radius', '0.15');
          trunk.setAttribute('height', '0.6');
          trunk.setAttribute('position', '0 0.3 0');
          trunk.setAttribute('color', '#8B4513'); // Saddle brown
          trunk.setAttribute('shadow', 'cast: true');
          container.appendChild(trunk);
          
          // Bottom tier - largest green cone (darkest green)
          const bottomTier = document.createElement('a-cone');
          bottomTier.setAttribute('radius-bottom', '0.8');
          bottomTier.setAttribute('radius-top', '0'); // Pointy top
          bottomTier.setAttribute('height', '1');
          bottomTier.setAttribute('position', '0 0.8 0');
          bottomTier.setAttribute('color', '#228B22'); // Forest green
          bottomTier.setAttribute('shadow', 'cast: true');
          container.appendChild(bottomTier);
          
          // Middle tier - medium green cone
          const middleTier = document.createElement('a-cone');
          middleTier.setAttribute('radius-bottom', '0.6');
          middleTier.setAttribute('radius-top', '0');
          middleTier.setAttribute('height', '0.8');
          middleTier.setAttribute('position', '0 1.4 0');
          middleTier.setAttribute('color', '#2E8B57'); // Sea green
          middleTier.setAttribute('shadow', 'cast: true');
          container.appendChild(middleTier);
          
          // Top tier - smallest green cone (lightest green)
          const topTier = document.createElement('a-cone');
          topTier.setAttribute('radius-bottom', '0.4');
          topTier.setAttribute('radius-top', '0');
          topTier.setAttribute('height', '0.6');
          topTier.setAttribute('position', '0 1.9 0');
          topTier.setAttribute('color', '#32CD32'); // Lime green
          topTier.setAttribute('shadow', 'cast: true');
          container.appendChild(topTier);
          
          // Star on top - gold octahedron (8-sided diamond shape)
          const star = document.createElement('a-octahedron');
          star.setAttribute('radius', '0.1');
          star.setAttribute('position', '0 2.3 0'); // At the very top
          star.setAttribute('color', '#FFD700'); // Gold
          container.appendChild(star);
        }
      });
    </script>
  </head>
  <body>
    <!-- 
      A-FRAME SCENE
      Main AR scene configuration with lighting, camera, and sky
    -->
    <a-scene
      ar-hit-test-spawn
      webxr="requiredFeatures: hit-test;"
      renderer="colorManagement: true; exposure: 1; toneMapping: ACESFilmic"
      shadow="type: pcfsoft"
      xr-mode-ui="XRMode: xr"
    >
      <!-- Directional light - simulates sunlight, casts shadows for realism -->
      <a-light type="directional" light="castShadow:true;" position="1 1 1" intensity="1.57"></a-light>
      
      <!-- AR Camera - positioned at typical user height (0.4m off ground) -->
      <!-- wasd-controls allow desktop testing with keyboard -->
      <a-camera position="0 0.4 0" wasd-controls="acceleration:10;"></a-camera>
      
      <!-- Sky - light blue background, automatically hidden when entering AR mode -->
      <a-sky color="#87CEEB" hide-on-enter-ar></a-sky>
    </a-scene>
  </body>
</html>
